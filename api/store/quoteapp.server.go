// Package SwaggerV3 provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo"
	"net/http"
	"strings"
)

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+RYzXLbNhB+FQzao0xKipzp8BSlSjtqM2lSN714NBkIWJFISQAGQMusR+/eAUBK/HMt",
	"N257yMWkiP3D7rffAr7HVBZKChDW4OQeG5pBQfzrbyR1D6WlAm05+I+cub87qQticYK5sC8XeIJtpSD8",
	"hBQ0PkywIAU40XrFWM1Fig+Ho6zcfgZq8QTfFbkTDAreq5MCraUe+qeSwZkRFGAMSR8IQsNNyTUwnFwf",
	"BTf92A4TfFNKCyNhcFu5J9yRQuVO5apiAqpTII2vCYaC8Lwr/JPMxErCq0wWEAmwY2o7ro1tsthVHRM/",
	"uzA5GTO7kjBmVWVS9CSni+liNn+xuHw5qiCNbWp00pnP5rMxaWM1gO3Kzr5DS0ooJ2h5C6IcDcuU21Jv",
	"u3pvlHKrI9KWpAG7Fgr/8q2GHU7wN/EJ+3EN/Njj72iEaE2qAUYtcX72mijlEGR1CQ5Tey6Y3JtuWHhy",
	"nt+gPHDdx2oAky/35rFWCtg9RTaEcQY8zbr5n82n09FuIhY0Jz0g76VkYykfAuytLEUKKESClqNK0kIv",
	"ewQxMFRzZbkUSO6QzRobo+gjAroRvhjbi9KcdsO7fDmNFpdHWVEW2yC658xmHdH5YixBvTLViW2lrc5J",
	"E2MTRONhyD0O5kBLzW115TASUkMU//QHeO7hAic4A8JAN9aT4/oJRor/DNWRyoyVGj6RMmxql9d45YXK",
	"OeUeCm5Rav4ncTn/qHPnxVqVxLG3QJSKzJ6kKeiIy1g68ZhxkkvXFIZKFSLVQFgSfOLE/0KVLDWqP7n+",
	"4RZOEoVkfFfVy4iLIE0olaVw6WhNDudyHj7BnQUtSL6S1HttwQUn+AcuGJKlRYXUgMjWvV6F2PEEl+29",
	"nbbk2VTsZBg3whIaOiTQOKZbyHOAVwWnWhq5sxGVhdPpuv7g9oGIUmj5fo0nOOcUhIFWey4VoRmgeTTt",
	"x7Lf7yPiVyOp07hWNfHb9fdv3l29uZhH0yizRe7ZAnRhftldgb71oB7uJ/YisYMEt2FWhTX0oSnFLWgT",
	"wp5F02jq7EoFgiiOE/wimkYzD1yb+RzHx6GYBvLu7vxXsKUWBpE8PxXbsY4H1JrhBP8I9uhbg1HSbc9Z",
	"mk+nTdpBBDQqh0yvGn82zkFzSDmb0mseHGHWtvGaO5/J9gAPpqQUjNmVOTrmwuktwo67wu9k0wc7WQoW",
	"5BZnyLVIAyfXLbq43hw2bm4WBdFVqEC3QGFIXtdDY1OPcueyW7olY750OBAeGPtasupJRTsjn4/V5hwT",
	"D7Rk4FdkM2KRAGAGWYm2gAhjwNy7GzGeJnGb0/2Q/2rQmnNjfSJuQs4aCJhAdDtS5vbZah6O+l9U88bE",
	"YCMpCNCcIi+AmuoNG2UwHK+782nSmWe9ZloyhggSsA/pGnbTBN9duFNxCuKi7pqLrWTVRT0KPhxRH0oU",
	"3/vHmh1Cz+cQ+Lbbiiv/velGRTQpwII2fkOPnA5OaR3cje5H24b73qhDmQTzbiKcjNchD7qm7ezR+4lL",
	"bKfHRvlxLW5Jzhlar5ApHWbgYY4M4QtpH+LILyp9qAEiD1X+MHlkSCLDRZrDUX98UL6ufGJ7Ne4lZeUO",
	"yKFhrUTae/gvS/VUOvy/5sCTRvGzQu3BcewPqqF02wqtV08YyB8VIzULPBkl/RlYelvsXwfNV35ueH6g",
	"ObnLodzvzqJPBYI7CuHz8xJggB8izgM3lov0nw5B9x7Sb0DfNug9XYxMcwNtXz9v59hNrHJwTe0LbY7x",
	"9P4/0q/2e9AOxaZ16EFSnO5KT7hx/t0d87A5/BUAAP//ulA403wVAAA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get all quotes
	// (GET /quote)
	GetQuotes(ctx echo.Context) error
	// Add a new quote
	// (POST /quote)
	AddQuote(ctx echo.Context) error
	// Delete a quote
	// (DELETE /quote/{quoteId})
	DeleteQuote(ctx echo.Context, quoteId int64, params DeleteQuoteParams) error
	// Find quote by ID
	// (GET /quote/{quoteId})
	GetQuoteById(ctx echo.Context, quoteId int64) error
	// Update an existing quote
	// (POST /quote/{quoteId})
	UpdateQuoteById(ctx echo.Context, quoteId int64) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetQuotes converts echo context to params.
func (w *ServerInterfaceWrapper) GetQuotes(ctx echo.Context) error {
	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetQuotes(ctx)
	return err
}

// AddQuote converts echo context to params.
func (w *ServerInterfaceWrapper) AddQuote(ctx echo.Context) error {
	var err error

	ctx.Set("quotestore_auth.Scopes", []string{"write:quotes", "read:quotes"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AddQuote(ctx)
	return err
}

// DeleteQuote converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteQuote(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "quoteId" -------------
	var quoteId int64

	err = runtime.BindStyledParameter("simple", false, "quoteId", ctx.Param("quoteId"), &quoteId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter quoteId: %s", err))
	}

	ctx.Set("quotestore_auth.Scopes", []string{"write:quotes", "read:quotes"})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteQuoteParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "api_key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("api_key")]; found {
		var ApiKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for api_key, got %d", n))
		}

		err = runtime.BindStyledParameter("simple", false, "api_key", valueList[0], &ApiKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter api_key: %s", err))
		}

		params.ApiKey = &ApiKey
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteQuote(ctx, quoteId, params)
	return err
}

// GetQuoteById converts echo context to params.
func (w *ServerInterfaceWrapper) GetQuoteById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "quoteId" -------------
	var quoteId int64

	err = runtime.BindStyledParameter("simple", false, "quoteId", ctx.Param("quoteId"), &quoteId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter quoteId: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetQuoteById(ctx, quoteId)
	return err
}

// UpdateQuoteById converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateQuoteById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "quoteId" -------------
	var quoteId int64

	err = runtime.BindStyledParameter("simple", false, "quoteId", ctx.Param("quoteId"), &quoteId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter quoteId: %s", err))
	}

	ctx.Set("quotestore_auth.Scopes", []string{"write:quotes", "read:quotes"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateQuoteById(ctx, quoteId)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/quote", wrapper.GetQuotes)
	router.POST("/quote", wrapper.AddQuote)
	router.DELETE("/quote/:quoteId", wrapper.DeleteQuote)
	router.GET("/quote/:quoteId", wrapper.GetQuoteById)
	router.POST("/quote/:quoteId", wrapper.UpdateQuoteById)

}
