// Package api provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get all quotes
	// (GET /quote)
	GetQuotes(ctx echo.Context) error
	// Add a new quote
	// (POST /quote)
	AddQuote(ctx echo.Context) error
	// Delete a quote
	// (DELETE /quote/{quoteId})
	DeleteQuote(ctx echo.Context, quoteId int64, params DeleteQuoteParams) error
	// Find quote by ID
	// (GET /quote/{quoteId})
	GetQuoteById(ctx echo.Context, quoteId int64) error
	// Update an existing quote
	// (POST /quote/{quoteId})
	UpdateQuoteById(ctx echo.Context, quoteId int64) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetQuotes converts echo context to params.
func (w *ServerInterfaceWrapper) GetQuotes(ctx echo.Context) error {
	var err error

	ctx.Set("userToken.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetQuotes(ctx)
	return err
}

// AddQuote converts echo context to params.
func (w *ServerInterfaceWrapper) AddQuote(ctx echo.Context) error {
	var err error

	ctx.Set("userToken.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AddQuote(ctx)
	return err
}

// DeleteQuote converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteQuote(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "quoteId" -------------
	var quoteId int64

	err = runtime.BindStyledParameter("simple", false, "quoteId", ctx.Param("quoteId"), &quoteId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter quoteId: %s", err))
	}

	ctx.Set("userToken.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteQuoteParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "api_key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("api_key")]; found {
		var ApiKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for api_key, got %d", n))
		}

		err = runtime.BindStyledParameter("simple", false, "api_key", valueList[0], &ApiKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter api_key: %s", err))
		}

		params.ApiKey = &ApiKey
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteQuote(ctx, quoteId, params)
	return err
}

// GetQuoteById converts echo context to params.
func (w *ServerInterfaceWrapper) GetQuoteById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "quoteId" -------------
	var quoteId int64

	err = runtime.BindStyledParameter("simple", false, "quoteId", ctx.Param("quoteId"), &quoteId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter quoteId: %s", err))
	}

	ctx.Set("userToken.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetQuoteById(ctx, quoteId)
	return err
}

// UpdateQuoteById converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateQuoteById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "quoteId" -------------
	var quoteId int64

	err = runtime.BindStyledParameter("simple", false, "quoteId", ctx.Param("quoteId"), &quoteId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter quoteId: %s", err))
	}

	ctx.Set("userToken.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateQuoteById(ctx, quoteId)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/quote", wrapper.GetQuotes)
	router.POST("/quote", wrapper.AddQuote)
	router.DELETE("/quote/:quoteId", wrapper.DeleteQuote)
	router.GET("/quote/:quoteId", wrapper.GetQuoteById)
	router.POST("/quote/:quoteId", wrapper.UpdateQuoteById)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+RXXZPaNhT9Kxq1j6wNhM10eAopaYdOJk26aV92mI6wLrYSW9JK17B0h//ekWQD/tgu",
	"pNv0IS+LF+6Xzj33XOuBJqrQSoJES6cP1CYZFMw/fmSp+9BGaTAowH8puPu7VqZgSKdUSHw5oQOKOw3h",
	"X0jB0P2ASlaAM61+sWiETOl+f7BVq0+QIB3Q+yJ3hsHBZ3VWYIwy3fyJ4nBmBQVYy9JHijBwVwoDnE5v",
	"D4bLdm37Ab0rFUJPGQJ37hPuWaFz53Kz4xJ2x0LqXAMKBRN50/gXlcm5gleZKiCSgH1ua2Es1ig2XfvM",
	"z25MzvrCzhX0RdWZki3L4WQ4GY1fTK5f9jooi3WPjj7j0XjUZ23RAGDTdvQDmSUsEYzMNiDL3rJsuSrN",
	"qun3Rmv3a481sjRwF6HwD98bWNMp/S4+cj+uiB97/h2CMGPYrsNRZC7P1jCtHYPQlOA4tRWSq61tlkUH",
	"5+UNzp3Uba4GMvl2L58apcDdY2VdGmcg0qyJ/2g8HPZOE0MwgrWIvFWK90HeJdhbVcoUSKiEzHqdFEIL",
	"PUY42MQIjUJJotYEszpGL/uYhGaFL/rOoo1ImuVdvxxGk+uDrSyLVTDdCo5Zw3Q86QOo1aYK2BPYKkzq",
	"Gusi6gxd7XE0h6Q0Anc3jiMBmtKC+ag+g/SElnRKM2AcTB1/SmclZsqIv5iD7AgS0+IzOD45RbpHMJLl",
	"c5X4oCcY0yn9SUhOVImkUAYIW7nHmy1LU5+lNLlLiqincWzD15FQXoLkWgWNlsiSQKugfTRZQZ4DvCpE",
	"YpRVa4wSVTifZuoPjrGEaU1m7xd0QHORgLRwwumZZkkGZBwN27Vst9uI+V8jZdK4crXx28WPb97dvLka",
	"R8MowyL3IwamsL+ub8BsPBO654m9SezwExgEPvxGfI2WDugGjA1lj6JhNHRxlQbJtKBT+iIaRiPfbcw8",
	"xvFhk6RB8Zon/w2wNNISlufkrs7gRtW3ccHplP4MeMhtwGrljucijYfDGnaQPjbTOheJd40/WSWPm/1s",
	"HazEo0eOToNXgvNMsTt8sGWSgLXrMicHLJzfJJy4afxOVciRtSolD3aTM+xOJo1ObxszdrvcL926KQpm",
	"dqEHzRaF3XJbae2y2oAuabN5M85982jQCbD4WvHdRW07A9GnunNOiEeGMsgSwYwhkQDcElRkBYRxDtw9",
	"O2W2qEx9xCCFfjd+M3zNhUUPxF3ArKaADVK3ZmWOz9bz8Ib8r3peh+gcJAUJRiTEG5C6exeNyoxzwoiE",
	"bQCjOysDen/lXhVTkFfVTFytFN9dVVL/4cDp0ID4wX8s+D7MdA5BT5uDNvff17OmmWEFIBjry+1dmEyL",
	"Pz/7V/cjaJ0Lw0PvUAjP/KqUQQjvFP8YvCq5MxOnyZ58aXfANiaoV/8WcsNywcliTmzpGAGPa2AoXyr8",
	"Ag0MCBP2WF/3gydWHLFCpjkc/PvX3Oudh63VwdaR5+6dMAwbKmJ8hq/ZiEul7P/S8IsW6dcikn/RDM1b",
	"7chifsE6/V1zVk35xTxpb7DSx+L/OW2+8a3//FRzdtdduz9cRA8FgfsEwteX8DKQizDnLywKmX7pCnPP",
	"AVwLZlNz83htsdM4dCA6uXlsxtTtm8blptdoeaindeVv9/I9GMdRe/JCQpQ83mQuuA/+0w1wv9z/HQAA",
	"//8dXKewTxQAAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}

